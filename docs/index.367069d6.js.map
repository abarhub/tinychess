{"mappings":"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GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAC3D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAG1CC,EAAO,CACT,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG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","sources":["node_modules/chess.js/dist/chess.js","src/app.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chess = exports.validateFen = exports.SQUARES = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\n/*\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nexports.SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n// NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n// ----------------------------------------------------------------------------\n// From https://github.com/jhlywa/chess.js/issues/230\n//\n// A lot of people are confused when they first see the internal representation\n// of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n// stores the board as an 8x16 array. This is purely for efficiency but has a\n// couple of interesting benefits:\n//\n// 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n//    square with 0x88, if the result is non-zero then the square is off the\n//    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n//    there are 8 possible directions in which the knight can move. These\n//    directions are relative to the 8x16 board and are stored in the\n//    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n//    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n//    (because of two-complement representation of -18). The non-zero result\n//    means the square is off the board and the move is illegal. Take the\n//    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n//    means the square is on the board.\n//\n// 2. The relative distance (or difference) between two squares on a 8x16 board\n//    is unique and can be used to inexpensively determine if a piece on a\n//    square can attack any other arbitrary square. For example, let's see if a\n//    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n//    -80. We add 119 to make the ATTACKS array index non-negative (because the\n//    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n//    bitmask of pieces that can attack from that distance and direction.\n//    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n//    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n//    example, we would check to see if 24 & 0x1 is non-zero, which it is\n//    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n//    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n//    there are no blocking pieces between E7 and E2. That's where the RAYS\n//    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n//    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n// prettier-ignore\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n// const RANK_3 = 5\n// const RANK_4 = 4\n// const RANK_5 = 3\n// const RANK_6 = 2\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n/**\n * Extracts the zero-based rank of an 0x88 square.\n */\nfunction rank(square) {\n    return square >> 4;\n}\n/**\n * Extracts the zero-based file of an 0x88 square.\n */\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n/**\n * Converts a 0x88 square to algebraic notation.\n */\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\n/* TODO: this needs a bit of work - it validates structure but completely\n * ignores content (e.g. doesn't verify that each side has a king) ... we should\n * rewrite this, and ditch the silly error_number field while we're at it */\nfunction validateFen(fen) {\n    const errors = [];\n    errors[0] = 'No errors.';\n    errors[1] = 'FEN string must contain six space-delimited fields.';\n    errors[2] = '6th field (move number) must be a positive integer.';\n    errors[3] = '5th field (half move counter) must be a non-negative integer.';\n    errors[4] = '4th field (en-passant square) is invalid.';\n    errors[5] = '3rd field (castling availability) is invalid.';\n    errors[6] = '2nd field (side to move) is invalid.';\n    errors[7] =\n        \"1st field (piece positions) does not contain 8 '/'-delimited rows.\";\n    errors[8] = '1st field (piece positions) is invalid [consecutive numbers].';\n    errors[9] = '1st field (piece positions) is invalid [invalid piece].';\n    errors[10] = '1st field (piece positions) is invalid [row too large].';\n    errors[11] = 'Illegal en-passant square';\n    /* 1st criterion: 6 space-seperated fields? */\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return { valid: false, errorNumber: 1, error: errors[1] };\n    }\n    /* 2nd criterion: move number field is a integer value > 0? */\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return { valid: false, errorNumber: 2, error: errors[2] };\n    }\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return { valid: false, errorNumber: 3, error: errors[3] };\n    }\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { valid: false, errorNumber: 4, error: errors[4] };\n    }\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n        return { valid: false, errorNumber: 5, error: errors[5] };\n    }\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { valid: false, errorNumber: 6, error: errors[6] };\n    }\n    /* 7th criterion: 1st field contains 8 rows? */\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return { valid: false, errorNumber: 7, error: errors[7] };\n    }\n    /* 8th criterion: every row is valid? */\n    for (let i = 0; i < rows.length; i++) {\n        /* check for right sum of fields AND not two numbers in succession */\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return { valid: false, errorNumber: 8, error: errors[8] };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return { valid: false, errorNumber: 9, error: errors[9] };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return { valid: false, errorNumber: 10, error: errors[10] };\n        }\n    }\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { valid: false, errorNumber: 11, error: errors[11] };\n    }\n    /* everything's okay! */\n    return { valid: true, errorNumber: 0, error: errors[0] };\n}\nexports.validateFen = validateFen;\n/* this function is used to uniquely identify ambiguous moves */\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /* if a move of the same piece type ends on the same to square, we'll\n         * need to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        /* if there exists a similar moving piece on the same rank and file\n           as the move in question, use the square as the disambiguator\n        */\n        if (sameRank > 0 && sameFile > 0) {\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /* if the moving piece rests on the same file, use the rank symbol\n               as the disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            /* else use the file symbol */\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            promotion: undefined,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return exports.PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return exports.KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n    constructor(fen = exports.DEFAULT_POSITION) {\n        this._board = new Array(128);\n        this._turn = exports.WHITE;\n        this._header = {};\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._epSquare = -1;\n        this._halfMoves = 0;\n        this._moveNumber = 0;\n        this._history = [];\n        this._comments = {};\n        this._castling = { w: 0, b: 0 };\n        this.load(fen);\n    }\n    clear(keepHeaders = false) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = exports.WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = keepHeaders ? this._header : {};\n        this._updateSetup(this.fen());\n    }\n    load(fen, keepHeaders = false) {\n        const tokens = fen.split(/\\s+/);\n        const position = tokens[0];\n        let square = 0;\n        if (!validateFen(fen).valid) {\n            return false;\n        }\n        this.clear(keepHeaders);\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? exports.WHITE : exports.BLACK;\n                this.put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(this.fen());\n        return true;\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let cflags = '';\n        if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n            cflags += 'K';\n        }\n        if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n            cflags += 'Q';\n        }\n        if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n            cflags += 'k';\n        }\n        if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n            cflags += 'q';\n        }\n        /* do we have an empty castling flag? */\n        cflags = cflags || '-';\n        const epflags = this._epSquare === EMPTY ? '-' : algebraic(this._epSquare);\n        return [\n            fen,\n            this._turn,\n            cflags,\n            epflags,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /* Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object.  if the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been  made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== exports.DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(exports.DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        /* check for piece */\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        /* check for valid square */\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        /* don't let the user place more than one king */\n        if (type == exports.KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === exports.KING) {\n            this._kings[color] = sq;\n        }\n        this._updateSetup(this.fen());\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === exports.KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            /* if empty square or wrong color */\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === exports.PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === exports.WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === exports.BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                /* if the piece is a knight or a king */\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        return this._attacked(swapColor(color), this._kings[color]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        // k.b. vs k.b. (of opposite colors) with mate in 1:\n        // 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n        //\n        // k.b. vs k.n. with mate in 1:\n        // 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === exports.BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[exports.BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        /* TODO: while this function is fine for casual use, a better\n          * implementation would use a Zobrist key (instead of FEN). the\n          * Zobrist key would be maintained in the make_move/undo_move\n          functions,\n          * avoiding the costly that we do below.\n          */\n        const moves = [];\n        const positions = {};\n        let repetition = false;\n        while (true) {\n            const move = this._undoMove();\n            if (!move)\n                break;\n            moves.push(move);\n        }\n        while (true) {\n            /* remove the last two fields in the FEN string, they're not needed\n             * when checking for draw by rep */\n            const fen = this.fen().split(' ').slice(0, 4).join(' ');\n            /* has the position occurred three or move times */\n            positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n            const move = moves.pop();\n            if (!move) {\n                break;\n            }\n            else {\n                this._makeMove(move);\n            }\n        }\n        return repetition;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, } = {}) {\n        const moves = this._moves({ square });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        var _a;\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        /* are we generating moves for a single square? */\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            /* did we run off the end of the board */\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === exports.PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                /* single square, non-capturing */\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, exports.PAWN);\n                    /* double square */\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                /* pawn captures */\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n                        addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === exports.KNIGHT || type === exports.KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /* check for castling if:\n         * a) we're generating all moves, or\n         * b) we're doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === exports.KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                /* king-side castling */\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                /* queen-side castling */\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /* return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured) */\n        if (!legal) {\n            return moves;\n        }\n        /* filter out illegal moves */\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { sloppy = false } = {}) {\n        /* The move function can be called with in the following parameters:\n            *\n            * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n            *\n            * .move({ from: 'h7', <- where the 'move' is a move object\n            (additional\n            *         to :'h8',      fields are ignored)\n            *         promotion: 'q',\n            *      })\n            */\n        // sloppy parser allows the move parser to work around over disambiguation\n        // bugs in Fritz and Chessbase\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, sloppy);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            /* convert the pretty move object to an ugly move object */\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        /* failed to find move */\n        if (!moveObj) {\n            return null;\n        }\n        /* need to make a copy of move because we can't generate SAN after\n           the move is made */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        /* if ep capture, remove the captured pawn */\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === exports.BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        /* if pawn promotion, replace with new piece */\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        /* if we moved the king */\n        if (this._board[move.to].type === exports.KING) {\n            this._kings[us] = move.to;\n            /* if we castled, move the rook next to the king */\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            /* turn off castling */\n            this._castling[us] = 0;\n        }\n        /* turn off castling if we move a rook */\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        /* turn off castling if we capture a rook */\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        /* if big pawn move, update the en passant square */\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === exports.BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */\n        if (move.piece === exports.PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === exports.BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        return move ? this._makePretty(move) : null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === exports.BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: exports.PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /* TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        /* pop all of history onto reversed_history */\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        /* special case of a commented starting position with no moves */\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            /* if the position started with black to move, start PGN with #. ... */\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                /* is there a comment preceding the first move? */\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                /* store the previous generated move_string if we have one */\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        /* are there any other leftover moves? */\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        /* is there a result? */\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /* history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // JAH: huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        /* NB: this does not preserve comment whitespace. */\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        /* wrap the PGN output at max_width */\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            /* if the current move will push past max_width */\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                /* don't end the line with whitespace */\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { sloppy = false, newlineChar = '\\r?\\n', } = {}) {\n        // option sloppy=true\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        // RegExp to split header. Takes advantage of the fact that header and movetext\n        // will always have a blank line between them (ie, two newline_char's).\n        // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\s*\\r?\\n){2}/\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '(?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        /* parse PGN header */\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /* sloppy parser should attempt to load a fen tag, even if it's\n         * the wrong case and doesn't include a corresponding [SetUp \"1\"] tag */\n        if (sloppy) {\n            if (fen) {\n                if (!this.load(fen, true)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            /* strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position] */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers && this.load(headers['FEN'], true))) {\n                    // second argument to load: don't clear the headers\n                    return false;\n                }\n            }\n        }\n        /* NB: the regexes below that delete move numbers, recursive\n         * annotations, and numeric annotation glyphs may also match\n         * text in comments. To prevent this, we transform comments\n         * by hex-encoding them in place and decoding them again after\n         * the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded,\n         * we use {en,de}codeURIComponent here to support arbitrary UTF8\n         * as a convenience for modern users */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /* encodeURI doesn't transform most ASCII characters,\n                 * so we handle these ourselves */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        /* delete header to get the moves */\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        /* encode comments so they don't get deleted below */\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        /* delete recursive annotation variations */\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        /* delete move numbers */\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        /* delete ... indicating black to move */\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        /* trim and get array of moves */\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        /* delete empty entries */\n        moves = moves.join(',').replace(/,,+/g, ',').split(',');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], sloppy);\n            /* invalid move */\n            if (move == null) {\n                /* was the move an end of game marker */\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                /* reset the end of game marker if making a valid move */\n                result = '';\n                this._makeMove(move);\n            }\n        }\n        /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n    * match the termination marker. Only do this when headers are\n            present,\n            * but the result tag is missing\n            */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n        return true;\n    }\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n      * (SAN)\n      *\n      * @param {boolean} sloppy Use the sloppy SAN generator to work around\n      over\n      * disambiguation bugs in Fritz and Chessbase.  See below:\n      *\n      * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n      * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n      * 4. ... Ne7 is technically the valid SAN\n      */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== exports.PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === exports.PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88\n    // coordinates\n    _moveFromSan(move, sloppy = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // strict parser failed and the sloppy parser wasn't used, return null\n        if (!sloppy) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        // The sloppy parser allows the user to parse non-standard chess\n        // notations. This parser is opt-in (by specifying the\n        // '{ sloppy: true }' setting) and is only run after the Standard\n        // Algebraic Notation (SAN) parser has failed.\n        //\n        // When running the sloppy parser, we'll run a regex to grab the piece,\n        // the to/from square, and an optional promotion piece. This regex will\n        // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n        // f7f8q, b1c3\n        // NOTE: Some positions and moves may be ambiguous when using the\n        // sloppy parser. For example, in this position:\n        // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\n        // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\n        // sloppy parser will default to the most most basic interpretation\n        // (which is b1c3 parsing to Nc3).\n        // FIXME: these var's are hoisted into function scope, this will need\n        // to change when switching to const/let\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n        //     piece         from              to       promotion\n        );\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            // The [a-h]?[1-8]? portion of the regex below handles moves that may\n            // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n            // when there is one legal knight move to e7). In this case, the value\n            // of 'from' variable will be a rank or file, not a square.\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (from && to) {\n                // hand-compare move properties with the results from our sloppy\n                // regex\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[from] == moves[i].from &&\n                    Ox88[to] == moves[i].to &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n                else if (overlyDisambiguated) {\n                    // SPECIAL CASE: we parsed a move string that may have an\n                    // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\n                    // variable will\n                    const square = algebraic(moves[i].from);\n                    if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                        Ox88[to] == moves[i].to &&\n                        (from == square[0] || from == square[1]) &&\n                        (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                        return moves[i];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            /* display the rank */\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    /* pretty = external move object */\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const move = {\n            color,\n            piece,\n            from: algebraic(from),\n            to: algebraic(to),\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n        };\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(this._makePretty(move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n}\nexports.Chess = Chess;\n//   return {\n//     /***************************************************************************\n//      * PUBLIC CONSTANTS (is there a better way to do this?)\n//      **************************************************************************/\n//     SQUARES: (function () {\n//       /* from the ECMA-262 spec (section 12.6.4):\n//        * \"The mechanics of enumerating the properties ... is\n//        * implementation dependent\"\n//        * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n//        * ordered correctly\n//        */\n//       var keys = []\n//       for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n//         if (i & 0x88) {\n//           i += 7\n//           continue\n//         }\n//         keys.push(algebraic(i))\n//       }\n//       return keys\n//     })(),\n//     FLAGS: FLAGS,\n// }\n","\r\n// import Chess from './node_module/node_modules/chess.js/dist/chess.js'\r\nimport { Chess } from 'chess.js'\r\n\r\nconsole.log('Hello world!');\r\n\r\nvar board = null\r\nvar game = new Chess()\r\n\r\n\r\nfunction makeRandomMove () {\r\n    var possibleMoves = game.moves()\r\n\r\n    // exit if the game is over\r\n    if (game.isGameOver()) return\r\n\r\n    var randomIdx = Math.floor(Math.random() * possibleMoves.length)\r\n    game.move(possibleMoves[randomIdx])\r\n    board.position(game.fen())\r\n\r\n    window.setTimeout(makeRandomMove, 500)\r\n}\r\n\r\n\r\nvar config = {\r\n    pieceTheme: 'img/chesspieces/wikipedia/{piece}.png',\r\n    position: 'start'\r\n}\r\n\r\nboard = Chessboard('board1', config)\r\n\r\n\r\nwindow.setTimeout(makeRandomMove, 500)\r\n"],"names":["Object","defineProperty","$91faaaa3fd58aec9$exports","value","Chess","validateFen","SQUARES","DEFAULT_POSITION","KING","QUEEN","ROOK","BISHOP","KNIGHT","PAWN","BLACK","WHITE","$91faaaa3fd58aec9$var$EMPTY","$91faaaa3fd58aec9$var$FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","$91faaaa3fd58aec9$var$BITS","$91faaaa3fd58aec9$var$Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","$91faaaa3fd58aec9$var$PAWN_OFFSETS","b","w","$91faaaa3fd58aec9$var$PIECE_OFFSETS","n","r","q","k","$91faaaa3fd58aec9$var$ATTACKS","$91faaaa3fd58aec9$var$RAYS","$91faaaa3fd58aec9$var$PIECE_MASKS","p","$91faaaa3fd58aec9$var$PROMOTIONS","$91faaaa3fd58aec9$var$ROOKS","square","flag","$91faaaa3fd58aec9$var$SECOND_RANK","$91faaaa3fd58aec9$var$TERMINATION_MARKERS","$91faaaa3fd58aec9$var$rank","$91faaaa3fd58aec9$var$file","$91faaaa3fd58aec9$var$isDigit","c","indexOf","$91faaaa3fd58aec9$var$algebraic","f","substring","$91faaaa3fd58aec9$var$swapColor","color","$91faaaa3fd58aec9$var$validateFen","fen","errors","tokens","split","length","valid","errorNumber","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","$91faaaa3fd58aec9$var$addMove","moves","from","to","piece","captured","flags","push","promotion","undefined","$91faaaa3fd58aec9$var$inferPieceType","san","pieceType","charAt","match","toLowerCase","$91faaaa3fd58aec9$var$strippedSan","move","replace","clear","keepHeaders","this","_board","Array","_kings","_turn","_castling","_epSquare","_halfMoves","_moveNumber","_history","_comments","_header","_updateSetup","load","position","put","type","empty","toUpperCase","cflags","epflags","join","reset","get","sq","remove","_attacked","difference","index","offset","j","blocked","_isKingAttacked","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","len","i1","isThreefoldRepetition","positions","repetition","_undoMove","slice","move1","pop","_makeMove","isDraw","isGameOver","verbose","map","_makePretty","_moveToSan","legal","_a","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","j1","castlingFrom","castlingTo","castlingFrom1","castlingTo1","legalMoves","len1","sloppy","moveObj","_moveFromSan","prettyMove","_push","kings","turn","castling","epSquare","undo","old","pgn","newline","maxWidth","result","headerExists","appendComment","moveString","comment","reversedHistory","prefix","Result","strip","wrapComment","width","token","currentWidth","includes","header","args","loadPgn","newlineChar","mask","str","trim","headerRegexResults","RegExp","exec","headerString","headers","headerObj","key","regex","parsePgnHeader","encodeComment","s","charCodeAt","toString","encodeURIComponent","toHex","decodeComment","startsWith","endsWith","decodeURIComponent","fromHex","ms","_match","bracket","semicolon","ravRegex","halfMove","keys","output","disambiguator","ambiguities","sameRank","sameFile","ambigFrom","ambigTo","$91faaaa3fd58aec9$var$getDisambiguator","cleanMove","matches","overlyDisambiguated","ascii","perft","depth","nodes","uglyMove","prettyFlags","board","row","history","moveHistory","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","getComments","deleteComments","constructor","console","log","$3015b282b063971c$var$board","$3015b282b063971c$var$game","Chessboard","pieceTheme","window","setTimeout","$3015b282b063971c$var$makeRandomMove","possibleMoves","randomIdx","Math","floor","random"],"version":3,"file":"index.367069d6.js.map"}